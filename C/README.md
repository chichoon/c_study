# C언어

## C

- 아주 옛날에 나온 언어 (1972년)
  - 그만큼 까다롭거나 복잡한 면이 있음 (요즘 언어들은 간결하게 나오는 추세)
- UNIX 운영체제를 작성하기 위해 만든 만큼, 컴퓨터 시스템 및 하드웨어와 밀접한 관계가 있다
  - 임베디드 환경에서 주로 많이 사용함

## 저장공간

- 컴퓨터의 모든 명령은 CPU에서 처리되는데, CPU는 연산 특화 장치라 데이터 저장 공간이 아주 작다
  - 레지스터 16개 \* 레지스터마다 64비트 = 1024비트 (128바이트)
  - 레지스터의 개수를 늘리는 것은 훨씬 어려움
- 따라서 CPU 옆에 **RAM** (Random Access Memory: 임의 접근 메모리) 라는 녀석을 붙여서 CPU 연산에 도움을 주도록 함
  - 램은 보통 8기가 정도의 크기를 가지므로, CPU보다 훨씬 많은 데이터를 담을 수 있음
  - 그렇기 때문에 CPU는 명령어들을 램에 저장해둔 뒤 연산 수행 시 필요한 데이터를 읽어서 사용
  - 램은 휘발성 메모리라는 단점이 있어, 하드디스크와 SSD 등을 이용해서 장기 보존용 데이터를 보관했다가 필요할 때만 꺼내 쓴다
    - 하드디스크에서 프로그램을 램에 복사 -> 램에 있는 프로그램과 명령어를 CPU측에서 읽어들여 연산
- 또한 CPU에는 빠르게 데이터를 레지스터에 불러올 수 있도록 **캐시 (Cache)**를 사용한다
  - 크기가 아주 작아 많은 데이터를 담지는 못하지만 CPU가 데이터를 읽어들이는 데 걸리는 속도가 아주아주아주빠름
  - 캐시는 계층별로 **L1, L2, L3**으로 분리되어 있다
    - **L1**은 크기가 제일 작지만 (256kb) 속도가 제일 빠름 (1나노초)
    - **L3**은 크기가 제일 크지만 (16mb) 속도가 제일 느림 (28나노초)
    - 따라서 가장 빠르게 필요한 데이터는 L1에 들어가고, 중요도 순으로 L2, L3에 배치됨
- 이렇게 CPU는 조만간 사용할 것 같은 데이터를 미리 캐시에 불러와 효율을 높인다
  - 그렇다고 CPU가 어떤 명령어가 언제 실행될 지 미래를 내다볼 수는 없기 때문에, 캐시 예측 알고리즘을 사용해서 미리 캐시를 적재하는 방식을 사용함
  - 캐시 예측에 실패해서 캐시 미스가 발생하면 속도가 좀 느려지겠지?

### CPU - 램 간 상호작용

- CPU가 램에서 데이터를 읽어올 때는 램의 **어느 위치**에서 데이터를 읽어올 지 알아야 한다
  - 램의 모든 데이터는 1 바이트 (8비트) 단위로 0번을 시작으로 고유의 주소가 부여되어 있음 (0x1230, 0x1234, 0x1238...)
  - CPU 측에서 이 주소값을 바탕으로 어디서 데이터를 읽어야 한다고 알려주면 램은 해당 주소값에 있는 데이터를 전달해 줌
  - 마찬가지로 CPU 측에서 어떤 주소값에 데이터를 저장해야 한다고 알려주면 램은 해당 위치 데이터를 CPU에게서 받은 데이터로 덮어씀
- 이때 중요한 것은 주소값 뿐만 아니라 **데이터의 크기**도 알려줘야 함
  - 0x1230 주소에서 1바이트만 읽을지, 4바이트를 읽어올지 같은
- 프로그램이란 이러한 **데이터 읽고 쓰기 명령어들의 총 집합체**라고 볼 수 있음

### 가상메모리? 물리메모리?

- 프로그램들이 램의 여러 부분을 나누어서 차지하며 독자적으로 돌아가는데, 이때 메모리 값을 잘못 건드리게 되면 충돌이 일어나 데이터가 손상될 수 있음
- 하지만 각 프로그램들이 어느 구역을 사용하고 있는지는 어떻게 알 수 있을까?
  - CPU가 보고 있는 메모리 주소값과 실제 메모리의 위치는 다르다
  - 이때 CPU가 보고 있는 주소값들은 실제 메모리 위치와 1대1 매칭됨
- **가상 메모리**는 CPU가 보고 있는 메모리와 그 메모리 주소
- **물리 메모리** 는 실제 램에서의 메모리 위치
- 가상 메모리와 물리 메모리간 변환은 **페이징**을 통해 이루어지고, 변환되는 최소 메모리 단위는 **페이지**라 부른다
  - 페이징 방식을 기록한 테이블이 **페이지 테이블**로, 이 페이지 테이블은 프로그램별로 하나씩 가지고 있기 때문에 서로 다른 프로그램이 같은 주소값을 참조하더라도 실제 물리 메모리는 겹치지 않는다

## 웨 C언어인가?

- 무언가를 빠르게 만드는 것에는 C가 딱히 적합하지 않음
- 하지만 **컴퓨터의 원리를 정확하게 이해**하는 데에 C만큼 좋은 것이 없다
- C언어에서 많은 언어들이 파생되어 나왔기 때문에, 다른 언어를 배우는 데에 도움을 준다
- C언어가 옛날 언어이기 때문에 C로 작성된 코드가 아주아주아주 많다
- 그리고 배울 내용이 많지 않다! (하지만 쉽지도 않다)
