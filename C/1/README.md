# C언어 #1 변수

### [예제 코드](variable.c)

## 주석

- 코드에 전혀 영향을 끼치지 않음
- 내 코드를 설명하고자 할 때 쓰인다
- 주석을 자주 남발하는 건 좀 그렇지만 코드 설명을 위해선 주석을 애용하자
  > //한줄 주석은 이렇게  
  > /\*  
  > 여러줄 주석은 이렇게  
  > \*/

## 수

- 우리는 실생활에서 십진법을 사용하지만 컴퓨터는 이진법을 씀
- 프로그래밍 시에는 이진수를 알아보기 편하게 16진법을 사용함

## 메모리 단위

- 한 개의 메모리 소자는 0 또는 1을 보관하는데, 이 이진수 한 자리 어치를 **Bit**이라 한다
- Bit이 8개 모이면 **Byte**가 된다 (00000000 ~ 11111111 = 0x00 ~ 0xFF = 0 ~ 256)
- 32Bit 컴퓨터에선 **1 워드가 32비트**, 64Bit 컴퓨터에선 **1 워드가 64비트**

## 변수 (Variable)

- 사용자가 메모리 주소에 일일히 값을 대입하는 건 쉽지 않은 일
- 그래서 변수를 사용하면 컴퓨터가 알아서 메모리의 특정 주소에 값을 저장해 준다
- 선언법은 [자료형] [변수명];
- 대입법은 [변수명] = [값];
- 선언과 대입을 동시에 하려면 [자료형] [변수명] = [값];

## 자료형

- 자료형 크기는 sizeof(변수) 또는 sizeof(자료형) 로 알 수 있음 (바이트 단위)

### char

- 1바이트
- unsigned char은 0 ~ 255
- signed char은 -128 ~ 127

### short

- 2바이트 이상
- unsigned short는 0부터 65535
- signed short는 -32768 ~ 32767

### int

- 보통 4바이트
- unsigned int는 0 ~ 4294967295
- signed int는 -2147483648 ~ 2147483647

### long

- 4바이트 이상 (32비트 시스템에서 4바이트, 64비트 시스템에서 8바이트)

### long long

- 8바이트 이상

### float

- 4바이트
- 부동소수

### double

- 8바이트
- 부동소수 (긴버전)

## 변수 출력

- %d = 10진수
- %o = 8진수
- %x = 16진수
- %c = char
- %s = string
- %f = float (부동소수)

### 자리수

- %d 대신 %[숫자]d를 입력할 경우 자리수를 맞추기 위해 남은 자리수에 **공백**을 출력
  > printf("%5d", 23);
  >
  > > ···23 (·는 공백)
- %f 대신 %.[숫자]f 를 입력할 경우 **소수점 이하 n째 자리**까지 출력
- 입력한 자리수보다 짧을 경우 뒤에 **0을 붙여서** 출력
  > printf("%.2f", 0.4235236);
  >
  > > 0.42
- %f 대신 %[숫자1].[숫자2]f를 입력할 경우 **위의 규칙 둘 다** 적용
  > printf("%7.5f", 3.451)
  >
  > > ·3.45100

## 변수 오버플로우

- 자료형이 **감당할 수 있는 크기** (n바이트) 를 넘어갈 경우 발생하는 현상
  > int a = 2147483647;  
  > a++;  
  > printf("a = %d", a);
  >
  > > a = -2147483648
- 위의 예시같은 경우는 int가 표현할 수 있는 최대값이 2147483647이기 때문
  - 이는 0111 1111 ... 1111 이 됨
  - 여기서 1을 더하면 1000 0000 ... 0000
  - 이것은 2의 보수 표현에 의하면 -2147483648이라서 결국 오버플로우가 발생하면 해당 음수가 출력되는 것
- Unsigned 자료형은 음수 대신 0이 나온다

### 2의 보수 표현

- 컴퓨터는 Signed 자료형의 음수를 표현할 때, 맨 왼쪽 (MSB) 비트를 이용한다
- 맨 왼쪽 비트가 0이면 양수, 1이면 음수
- 그렇다면 0111이 7이니까 1111은 -7인가?
  - 그렇지 않다
  - 그렇게 되면 1000도 0000도 같은 0이기 때문에 연산량이 늘어남
  - 덧셈 및 뺄셈 알고리즘이 복잡해짐
- 이러한 단점을 보완하는 것이 **2의 보수 표현법**
  - 2의 보수 표현법 체계에선 어떤 수의 부호를 바꾸려면 비트 반전 후 1을 더한다
  - 0111의 비트를 반전하고 1을 더하면 1001 = -7 이 되는 것이다
  - 이 방식을 이용하면 0000의 음수는 1111 + 0001 = 0000이므로 0을 표현하는 방법이 1가지밖에 없어 간편

## 변수 이름 규칙

- 대소문자가 구분된다
- 숫자가 변수명 맨 앞에 올 수 없다
- 변수는 알파벳, 숫자, \_ 기호로만 이뤄져야 한다
- 변수 이름 내에 띄어쓰기 하지 않기
- 예약어로 지정된 단어들은 사용 불가
  - 자료형, true, false 등

### 가급적 지키면 좋을 변수이름 짓기 규칙

- 남이 봐도 딱 알아볼 수 있을 만한 이름
  - 무엇을 의미하는지?
- 한국말을 영어발음대로 쓴 이름은 쓰지 말자
- 코드 처음부터 끝까지 한 가지 형식으로 쓰기
  - Camel Case: 단어를 대소문자로 구분
    > ThisIsNewVar
  - \_ 를 이용한 띄어쓰기
    > this_is_new_var
